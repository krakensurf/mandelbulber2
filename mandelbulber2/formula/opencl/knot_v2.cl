/**
 * Mandelbulber v2, a 3D fractal generator  _%}}i*<.        ____                _______
 * Copyright (C) 2020 Mandelbulber Team   _>]|=||i=i<,     / __ \___  ___ ___  / ___/ /
 *                                        \><||i|=>>%)    / /_/ / _ \/ -_) _ \/ /__/ /__
 * This file is part of Mandelbulber.     )<=i=]=|=i<>    \____/ .__/\__/_//_/\___/____/
 * The project is licensed under GPLv3,   -<>>=|><|||`        /_/
 * see also COPYING file in this folder.    ~+{i%+++
 *
 * knotv2
 * knot thingy by knighty (2012). Based on an idea by DarkBeam from fractalforums
 *(http://www.fractalforums.com/new-theories-and-research/not-fractal-but-funny-trefoil-knot-routine/30/)

 * This file has been autogenerated by tools/populateUiInformation.php
 * from the file "fractal_knot_v2.cpp" in the folder formula/definition
 * D O    N O T    E D I T    T H I S    F I L E !
 */

REAL4 KnotV2Iteration(REAL4 z, __constant sFractalCl *fractal, sExtendedAuxCl *aux)
{
	REAL polyfoldOrder = fractal->transformCommon.int2;

	if (fractal->transformCommon.functionEnabledAxFalse) z.x = fabs(z.x);
	if (fractal->transformCommon.functionEnabledAyFalse) z.y = fabs(z.y);
	if (fractal->transformCommon.functionEnabledAzFalse) z.z = fabs(z.z);
	z += fractal->transformCommon.offset000;

	REAL4 zc = z;
	zc.z *= fractal->transformCommon.scaleA1;
	REAL mobius = (mad(1.0f, fractal->transformCommon.intA1,
									native_divide(fractal->transformCommon.intB1, polyfoldOrder)))
								* atan2(zc.y, zc.x);

	zc.x = native_sqrt(mad(zc.x, zc.x, zc.y * zc.y)) - fractal->transformCommon.offsetA2;
	REAL temp = zc.x;
	REAL c = native_cos(mobius);
	REAL s = native_sin(mobius);
	zc.x = mad(c, zc.x, s * zc.z);
	zc.z = mad(-s, temp, c * zc.z);

	REAL m = 1.0f * native_divide(polyfoldOrder, M_PI_2x);
	REAL angle1 = floor(mad(m, (M_PI_2 - atan2(zc.x, zc.z)), 0.5f)) / m;

	temp = zc.x;
	c = native_cos(angle1);
	s = native_sin(angle1);
	zc.x = mad(c, zc.x, s * zc.z);
	zc.z = mad(-s, temp, c * zc.z);

	zc.x -= fractal->transformCommon.offset05;

	REAL len = native_sqrt(mad(zc.x, zc.x, zc.z * zc.z));

	if (fractal->transformCommon.functionEnabledCFalse) len = min(len, max(fabs(zc.x), fabs(zc.z)));

	if (fractal->transformCommon.functionEnabledEFalse) z = zc;
	REAL colorDist = aux->dist;
	if (!fractal->transformCommon.functionEnabledDFalse)
		aux->DE0 = len - fractal->transformCommon.offset01;
	else
		aux->DE0 = min(aux->dist, len - fractal->transformCommon.offset01);
	aux->dist = native_divide(aux->DE0, aux->DE);

	// aux->color
	if (fractal->foldColor.auxColorEnabled)
	{
		REAL colorAdd = 0.0f;
		REAL ang =
			(M_PI_F - 2.0f * fabs(atan(native_divide(zc.x, zc.z)))) * native_divide(2.0f, M_PI_F);

		if (fmod(ang, 2.0f) < 1.0f) colorAdd += fractal->foldColor.difs0000.x;
		colorAdd += fractal->foldColor.difs0000.y * fabs(ang);
		colorAdd += fractal->foldColor.difs0000.z * fabs(ang * zc.x);
		colorAdd += fractal->foldColor.difs0000.w * angle1;

		colorAdd += fractal->foldColor.difs1;
		if (fractal->foldColor.auxColorEnabledA)
		{
			if (colorDist != aux->dist) aux->color += colorAdd;
		}
		else
			aux->color += colorAdd;
	}

	// DE tweak
	if (fractal->analyticDE.enabledFalse) aux->dist = aux->dist * fractal->analyticDE.scale1;
	return z;
}